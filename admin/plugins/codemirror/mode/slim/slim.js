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);
        if (stream.match(/^\\$/)) {
          continueLine(state, column);
          return "lineContinuation";
        }
        var style = tokenize(stream, state);
        if (stream.eol() && stream.current().match(/(?:^|[^\\])(?:\\\\)*\\$/)) {
          stream.backUp(1);
        }
        return style;
      };
    }
    function commaContinuable(column, tokenize) {
      return function(stream, state) {
        finishContinue(state);
        var style = tokenize(stream, state);
        if (stream.eol() && stream.current().match(/,$/)) {
          continueLine(state, column);
        }
        return style;
      };
    }

    function rubyInQuote(endQuote, tokenize) {
      // TODO: add multi line support
      return function(stream, state) {
        var ch = stream.peek();
        if (ch == endQuote && state.rubyState.tokenize.length == 1) {
          // step out of ruby context as it seems to complete processing all the braces
          stream.next();
          state.tokenize = tokenize;
          return "closeAttributeTag";
        } else {
          return ruby(stream, state);
        }
      };
    }
    function startRubySplat(tokenize) {
      var rubyState;
      var runSplat = function(stream, state) {
        if (state.rubyState.tokenize.length == 1 && !state.rubyState.context.prev) {
          stream.backUp(1);
          if (stream.eatSpace()) {
            state.rubyState = rubyState;
            state.tokenize = tokenize;
            return tokenize(stream, state);
          }
          stream.next();
        }
        return ruby(stream, state);
      };
      return function(stream, state) {
        rubyState = state.rubyState;
        state.rubyState = CodeMirror.startState(rubyMode);
        state.tokenize = runSplat;
        return ruby(stream, state);
      };
    }

    function ruby(stream, state) {
      return rubyMode.token(stream, state.rubyState);
    }

    function htmlLine(stream, state) {
      if (stream.match(/^\\$/)) {
        return "lineContinuation";
      }
      return html(stream, state);
    }
    function html(stream, state) {
      if (stream.match(/^#\{/)) {
        state.tokenize = rubyInQuote("}", state.tokenize);
        return null;
      }
      return maybeBackup(stream, state, /[^\\]#\{/, 1, htmlMode.token(stream, state.htmlState));
    }

    function startHtmlLine(lastTokenize) {
      return function(stream, state) {
        var style = htmlLine(stream, state);
        if (stream.eol()) state.tokenize = lastTokenize;
        return style;
      };
    }

    function startHtmlMode(stream, state, offset) {
      state.stack = {
        parent: state.stack,
        style: "html",
        indented: stream.column() + offset, // pipe + space
        tokenize: state.line
      };
      state.line = state.tokenize = html;
      return null;
    }

    function comment(stream, state) {
      stream.skipToEnd();
      return state.stack.style;
    }

    function commentMode(stream, state) {
      state.stack = {
        parent: state.stack,
        style: "comment",
        indented: state.indented + 1,
        tokenize: state.line
      };
      state.line = comment;
      return comment(stream, state);
    }

    function attributeWrapper(stream, state) {
      if (stream.eat(state.stack.endQuote)) {
        state.line = state.stack.line;
        state.tokenize = state.stack.tokenize;
        state.stack = state.stack.parent;
        return null;
      }
      if (stream.match(wrappedAttributeNameRegexp)) {
        state.tokenize = attributeWrapperAssign;
        return "slimAttribute";
      }
      stream.next();
      return null;
    }
    function attributeWrapperAssign(stream, state) {
      if (stream.match(/^==?/)) {
        state.tokenize = attributeWrapperValue;
        return null;
      }
      return attributeWrapper(stream, state);
    }
    function attributeWrapperValue(stream, state) {
      var ch = stream.peek();
      if (ch == '"' || ch == "\'") {
        state.tokenize = readQuoted(ch, "string", true, false, attributeWrapper);
        stream.next();
        return state.tokenize(stream, state);
      }
      if (ch == '[') {
        return startRubySplat(attributeWrapper)(stream, state);
      }
      if (stream.match(/^(true|false|nil)\b/)) {
        state.tokenize = attributeWrapper;
        return "keyword";
      }
      return startRubySplat(attributeWrapper)(stream, state);
    }

    function startAttributeWrapperMode(state, endQuote, tokenize) {
      state.stack = {
        parent: state.stack,
        style: "wrapper",
        indented: state.indented + 1,
        tokenize: tokenize,
        line: state.line,
        endQuote: endQuote
      };
      state.line = state.tokenize = attributeWrapper;
      return null;
    }

    function sub(stream, state) {
      if (stream.match(/^#\{/)) {
        state.tokenize = rubyInQuote("}", state.tokenize);
        return null;
      }
      var subStream = new CodeMirror.StringStream(stream.string.slice(state.stack.indented), stream.tabSize);
      subStream.pos = stream.pos - state.stack.indented;
      subStream.start = stream.start - state.stack.indented;
      subStream.lastColumnPos = stream.lastColumnPos - state.stack.indented;
      subStream.lastColumnValue = stream.lastColumnValue - state.stack.indented;
      var style = state.subMode.token(subStream, state.subState);
      stream.pos = subStream.pos + state.stack.indented;
      return style;
    }
    function firstSub(stream, state) {
      state.stack.indented = stream.column();
      state.line = state.tokenize = sub;
      return state.tokenize(stream, state);
    }

    function createMode(mode) {
      var query = embedded[mode];
      var spec = CodeMirror.mimeModes[query];
      if (spec) {
        return CodeMirror.getMode(config, spec);
      }
      var factory = CodeMirror.modes[query];
      if (factory) {
        return factory(config, {name: query});
      }
      return CodeMirror.getMode(config, "null");
    }

    function getMode(mode) {
      if (!modes.hasOwnProperty(mode)) {
        return modes[mode] = createMode(mode);
      }
      return modes[mode];
    }

    function startSubMode(mode, state) {
      var subMode = getMode(mode);
      var subState = CodeMirror.startState(subMode);

      state.subMode = subMode;
      state.subState = subState;

      state.stack = {
        parent: state.stack,
        style: "sub",
        indented: state.indented + 1,
        tokenize: state.line
      };
      state.line = state.tokenize = firstSub;
      return "slimSubmode";
    }

    function doctypeLine(stream, _state) {
      stream.skipToEnd();
      return "slimDoctype";
    }

    function startLine(stream, state) {
      var ch = stream.peek();
      if (ch == '<') {
        return (state.tokenize = startHtmlLine(state.tokenize))(stream, state);
      }
      if (stream.match(/^[|']/)) {
        return startHtmlMode(stream, state, 1);
      }
      if (stream.match(/^\/(!|\[\w+])?/)) {
        return commentMode(stream, state);
      }
      if (stream.match(/^(-|==?[<>]?)/)) {
        state.tokenize = lineContinuable(stream.column(), commaContinuable(stream.column(), ruby));
        return "slimSwitch";
      }
      if (stream.match(/^doctype\b/)) {
        state.tokenize = doctypeLine;
        return "keyword";
      }

      var m = stream.match(embeddedRegexp);
      if (m) {
        return startSubMode(m[1], state);
      }

      return slimTag(stream, state);
    }

    function slim(stream, state) {
      if (state.startOfLine) {
        return startLine(stream, state);
      }
      return slimTag(stream, state);
    }

    function slimTag(stream, state) {
      if (stream.eat('*')) {
        state.tokenize = startRubySplat(slimTagExtras);
        return null;
      }
      if (stream.match(nameRegexp)) {
        state.tokenize = slimTagExtras;
        return "slimTag";
      }
      return slimClass(stream, state);
    }
    function slimTagExtras(stream, state) {
      if (stream.match(/^(<>?|><?)/)) {
        state.tokenize = slimClass;
        return null;
      }
      return slimClass(stream, state);
    }
    function slimClass(stream, state) {
      if (stream.match(classIdRegexp)) {
        state.tokenize = slimClass;
        return "slimId";
      }
      if (stream.match(classNameRegexp)) {
        state.tokenize = slimClass;
        return "slimClass";
      }
      return slimAttribute(stream, state);
    }
    function slimAttribute(stream, state) {
      if (stream.match(/^([\[\{\(])/)) {
        return startAttributeWrapperMode(state, closing[RegExp.$1], slimAttribute);
      }
      if (stream.match(attributeNameRegexp)) {
        state.tokenize = slimAttributeAssign;
        return "slimAttribute";
      }
      if (stream.peek() == '*') {
        stream.next();
        state.tokenize = startRubySplat(slimContent);
        return null;
      }
      return slimContent(stream, state);
    }
    function slimAttributeAssign(stream, state) {
      if (stream.match(/^==?/)) {
        state.tokenize = slimAttributeValue;
        return null;
      }
      // should never happen, because of forward lookup
      return slimAttribute(stream, state);
    }

    function slimAttributeValue(stream, state) {
      var ch = stream.peek();
      if (ch == '"' || ch == "\'") {
        state.tokenize = readQuoted(ch, "string", true, false, slimAttribute);
        stream.next();
        return state.tokenize(stream, state);
      }
      if (ch == '[') {
        return startRubySplat(slimAttribute)(stream, state);
      }
      if (ch == ':') {
        return startRubySplat(slimAttributeSymbols)(stream, state);
      }
      if (stream.match(/^(true|false|nil)\b/)) {
        state.tokenize = slimAttribute;
        return "keyword";
      }
      return startRubySplat(slimAttribute)(stream, state);
    }
    function slimAttributeSymbols(stream, state) {
      stream.backUp(1);
      if (stream.match(/^[^\s],(?=:)/)) {
        state.tokenize = startRubySplat(slimAttributeSymbols);
        return null;
      }
      stream.next();
      return slimAttribute(stream, state);
    }
    function readQuoted(quote, style, embed, unescaped, nextTokenize) {
      return function(stream, state) {
        finishContinue(state);
        var fresh = stream.current().length == 0;
        if (stream.match(/^\\$/, fresh)) {
          if (!fresh) return style;
          continueLine(state, state.indented);
          return "lineContinuation";
        }
        if (stream.match(/^#\{/, fresh)) {
          if (!fresh) return style;
          state.tokenize = rubyInQuote("}", state.tokenize);
          return null;
        }
        var escaped = false, ch;
        while ((ch = stream.next()) != null) {
          if (ch == quote && (unescaped || !escaped)) {
            state.tokenize = nextTokenize;
            break;
          }
          if (embed && ch == "#" && !escaped) {
            if (stream.eat("{")) {
              stream.backUp(2);
              break;
            }
          }
          escaped = !escaped && ch == "\\";
        }
        if (stream.eol() && escaped) {
          stream.backUp(1);
        }
        return style;
      };
    }
    function slimContent(stream, state) {
      if (stream.match(/^==?/)) {
        state.tokenize = ruby;
        return "slimSwitch";
      }
      if (stream.match(/^\/$/)) { // tag close hint
        state.tokenize = slim;
        return null;
      }
      if (stream.match(/^:/)) { // inline tag
        state.tokenize = slimTag;
        return "slimSwitch";
      }
      startHtmlMode(stream, state, 0);
      return state.tokenize(stream, state);
    }

    var mode = {
      // default to html mode
      startState: function() {
        var htmlState = CodeMirror.startState(htmlMode);
        var rubyState = CodeMirror.startState(rubyMode);
        return {
          htmlState: htmlState,
          rubyState: rubyState,
          stack: null,
          last: null,
          tokenize: slim,
          line: slim,
          indented: 0
        };
      },

      copyState: function(state) {
        return {
          htmlState : CodeMirror.copyState(htmlMode, state.htmlState),
          rubyState: CodeMirror.copyState(rubyMode, state.rubyState),
          subMode: state.subMode,
          subState: state.subMode && CodeMirror.copyState(state.subMode, state.subState),
          stack: state.stack,
          last: state.last,
          tokenize: state.tokenize,
          line: state.line
        };
      },

      token: function(stream, state) {
        if (stream.sol()) {
          state.indented = stream.indentation();
          state.startOfLine = true;
          state.tokenize = state.line;
          while (state.stack && state.stack.indented > state.indented && state.last != "slimSubmode") {
            state.line = state.tokenize = state.stack.tokenize;
            state.stack = state.stack.parent;
            state.subMode = null;
            state.subState = null;
          }
        }
        if (stream.eatSpace()) return null;
        var style = state.tokenize(stream, state);
        state.startOfLine = false;
        if (style) state.last = style;
        return styleMap.hasOwnProperty(style) ? styleMap[style] : style;
      },

      blankLine: function(state) {
        if (state.subMode && state.subMode.blankLine) {
          return state.subMode.blankLine(state.subState);
        }
      },

      innerMode: function(state) {
        if (state.subMode) return {state: state.subState, mode: state.subMode};
        return {state: state, mode: mode};
      }

      //indent: function(state) {
      //  return state.indented;
      //}
    };
    return mode;
  }, "htmlmixed", "ruby");

  CodeMirror.defineMIME("text/x-slim", "slim");
  CodeMirror.defineMIME("application/x-slim", "slim");
});
