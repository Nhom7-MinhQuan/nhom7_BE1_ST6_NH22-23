n scroll to and select it. If it\n   * doesn't exist, do nothing.\n   * @param term The search term.\n   * @param searchOptions Search options.\n   * @return Whether a result was found.\n   */\n  public findPrevious(term: string, searchOptions?: ISearchOptions): boolean {\n    if (!this._terminal) {\n      throw new Error('Cannot use addon until it has been loaded');\n    }\n\n    if (!term || term.length === 0) {\n      this._terminal.clearSelection();\n      return false;\n    }\n\n    const isReverseSearch = true;\n    let startRow = this._terminal.buffer.active.baseY + this._terminal.rows;\n    let startCol = this._terminal.cols;\n    let result: ISearchResult | undefined;\n    const incremental = searchOptions ? searchOptions.incremental : false;\n    let currentSelection: ISelectionPosition | undefined;\n    if (this._terminal.hasSelection()) {\n      currentSelection = this._terminal.getSelectionPosition()!;\n      // Start from selection start if there is a selection\n      startRow = currentSelection.startRow;\n      startCol = currentSelection.startColumn;\n    }\n\n    this._initLinesCache();\n    const searchPosition: ISearchPosition = {\n      startRow,\n      startCol\n    };\n\n    if (incremental) {\n      result = this._findInLine(term, searchPosition, searchOptions, false);\n      if (!(result && result.row === startRow && result.col === startCol)) {\n        result = this._findInLine(term, searchPosition, searchOptions, true);\n      }\n    } else {\n      result = this._findInLine(term, searchPosition, searchOptions, isReverseSearch);\n    }\n\n    // Search from startRow - 1 to top\n    if (!result) {\n      searchPosition.startCol = Math.max(searchPosition.startCol, this._terminal.cols);\n      for (let y = startRow - 1; y >= 0; y--) {\n        searchPosition.startRow = y;\n        result = this._findInLine(term, searchPosition, searchOptions, isReverseSearch);\n        if (result) {\n          break;\n        }\n      }\n    }\n    // If we hit the top and didn't search from the very bottom wrap back down\n    if (!result && startRow !== (this._terminal.buffer.active.baseY + this._terminal.rows)) {\n      for (let y = (this._terminal.buffer.active.baseY + this._terminal.rows); y >= startRow; y--) {\n        searchPosition.startRow = y;\n        result = this._findInLine(term, searchPosition, searchOptions, isReverseSearch);\n        if (result) {\n          break;\n        }\n      }\n    }\n\n    // If there is only one result, return true.\n    if (!result && currentSelection) return true;\n\n    // Set selection and scroll if a result was found\n    return this._selectResult(result);\n  }\n\n  /**\n   * Sets up a line cache with a ttl\n   */\n  private _initLinesCache(): void {\n    const terminal = this._terminal!;\n    if (!this._linesCache) {\n      this._lin